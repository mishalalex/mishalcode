# MISHALCODE
------------

### Goal
--------
To create an online platform where users can solve coding challenges in different languages similar to leetcode or geeksforgeeks

### Technologies used
---------------------
### Backened - NodeJs, Express, Postgres, Prisma, Judge0
### Frontend - ReactJs, Tailwind-Css, DaisyUI, Zustand, Zod and React-Hook Forms

### API Architecture
--------------------
1. Authentication
2. Problem Management (CRUD operation related to the problem)
3. Code execution 
4. Submission
5. Playlist creation for a set of problems


### How does our platform operates
----------------------------------



### Steps followed
-------------------
1. folder -> mkdir backend frontend
2. file -> .gitignore
   1. added 'node_modules' and '.env' to this file
3. 'nodemmon' is installed universally via "npm i -g nodemon" command

Backend Folder
--------------
1. folder -> backend/src (here we will keep the backend code)
2. install express and dotenv packages
3. file -> backend/src/index.js
   1. setup a simple server using express and getting the port from dotenv file
4. prisma
   1. npm i prisma @prisma/client 
   2. npx prisma init (scaffolding prisma configurations are setup)
5. postgres
   1. we will run docker for postgres where the credentials are posted on environment vairable with port mapping to 5432 in detach mode
   2. docker command 'docker run --name my-postgres -e POSTGRES_USER=myuser -e POSTGRES_PASSWORD=mypassword -p 5432:5432 -d postgres'
   3. it will return a db connect url - "postgresql://myuser:mypassword@localhost:5432/postgres"
   4. update the database url in env file
6. folder -> src/libs
7. file -> src/libs/db.js (we will keep prisma client)
8. Update schema.prisma file with a db model
9. prisma commands to run 
   1.  npx prisma generate (update the db.js file with the prisma client setup code)
   2.  npx prisma migrate dev
   3.  npx prisma db push 
   4.  npx prisma studio
10. code the first route -> auth routes
    1.  folder -> src/routes -> file -> auth.routes.js
    2.  create an express routes -> const authRouter = express.Router()
    3.  create routes for register, login, logout and check like authRouter.post('/register', register) // 'register' in controller will be made in the second 
11. code the first controller -> auth controller
    1.  folder -> src/controllers -> file -> auth.controller.js
    2.  npm i bcryptjs
    3.  create controller for each routes like -> export const register = async (req, res) => {}
    4.  generate a 32 char random hex string using openssl command in bash -> "openssl rand -hex 32"
    5.  make an entry in the .env file the above random string as the JWT_SECRET
12. code the auth controller for register route
    1.  get the data from the request by destructuring the request body
    2.  in a try-catch block, check whethehr a user exists in the db with the given email
    3.  if yes, throw an error
    4.  if no, then continue by creating a hash for the password 
    5.  make a db entry with the request data including the hashed password
    6.  make a JWT token using user id (autogenerated as configured in the prisma), JWT_SECRET in env file and an expiresIn
    7.  configure cookie using cookie-parser library by app.use(cookieParser()) in index.js file
    8.  configure cookie to be sent in response in the auth controller in response using res.cookie("jwt", token, {<other details>})
    9.  test using api test runner whether it is working
13. code the auth controller for login route
    1.  get the data from the request by destructuring the request body
    2.  in a try-catch block: 
        1.  check whether the user exists in db with the given email, return error if doesn't
        2.  check whether the passwords match by comparing the hashed passwords using bcryptjs
        3.  once checked, create a JWT token to e sent to the user and return a 200 success response
14. code the auth controller for logout route
    1.  in a try-catch block:
        1.  delete the stored cookie using 'res.clearCookies' method
        2.  return a success message 
15. code the auth controller for check route
    1.  in a try-catch block:
        1.  return a success message that user has been authenticated successfully
16. write a middleware for authenticate user
    1.  get the jwt cookie from req.cookies.jwt
    2.  throw error if no token
    3.  decode the cookie using JWT_SECRET with jwt.verify("jwt",JWT_SECRET) method
    4.  throw error if decoding isn't successful
    5.  find the user from db from the id in the decoded cookie
    6.  throw error if no user found
    7.  if user found then add the user to the request by 'req.user = user' and call the next() method
17. create a new model problem
    1.  problem model is for problems which the user can solve
    2.  build a relation to user model with one user to many problem relationship that if a user is deleted, all the problems created by the user is also deleted
    3.  run prisma commands to set the db:
        1.  npx prisma generate // prisma generates the new models in the schema.model in the prisma client instance
        2.  npx prisma migrate dev // migrates the database from prisma client 
        3.  npx prisma db push // pushes the changes to db
        4.  npx prisma studio // opens UI for prisma
18. install & setup judge0 using docker (can be skipped by using sulu judge0 api (third party api))
    1. install docker docker-compose docker.io
       1. sudo apt install docker docker-compose docker.io
    2. link to download: wget https://github.com/judge0/judge0/releases/download/v1.13.1/judge0-v1.13.1.zip
    3. cd to location -> unzip judge0-v1.13.1.zip 
    4. run -> docker-compose up -d db redis
    5. run -> docker-compose up -d (after ~ 10 sec) - it will take some time to download and setup for the first time
    6. once done, check whether it is working fine by going to -> http://localhost:2358/docs -> if you can see the docs for judge0 then everything is properly setup
 19. create problemRoutes and problemController
     1.  update index.js to add a new route to 'api/v1/problems' to add problem endpoints
     2.  create a new middleware to check whether the user has a role 'ADMIN' 
         1.  we can put after the 'authMiddleware' in our routes to restrict access to ADMIN only endpoints
     3.  file -> src/routes/problem.routes.js
     4.   add routes for the following (all of them requires the 'authMiddleware' check):
          1.   create a problem (admin)
          2.   get all problems
          3.   get all problems solved by user (user specific)
          4.   get problem by id
          5.   update a problem (admin)
          6.   delete a problem (admin)
     5.   file > src/controller/problem.controller.js
     6.   add scaffolding controllers for each of the above routes in problem
19.  create judge0.lib.js
     1.   its a simple function which returns an id for a given language
     2.   it has an object which has language-languageId key-value pairs
20. 'create-problem' controller
    1.  get all the required fields from request body
    2.  check once more whether the user is an admin (though we check it with middleware)
    3.  request body should have a property called 'referenceCode' which has two sub properties - 'language', 'solutionCode' - which judje0 expects
    4.  get languageId stored in judge0.lib.js using a method with 'language' to check which language the user is adding the problem in & verify that language is supported
    5.  verify the testcases are sent by the user as an array
    6.  create a 'submissions' object which can be passed to judge0 using the data sent by user
    7.  get the results from judge0 using 'submitBatch' method which comes as an array of 'tokens' where each item is an object
    8.  extract the tokens out of the submission results using Array.map method
    9.  using the tokens from the result, poll judje0 for all the submissions until all submissions are done using 'pollBatchResults' method in judge0.utils.js
    10. verify that the test cases have passed (id=3 means passed) using a for loop
    11. once all done, then save the problem in the database and return success message to user
21. 'get-problems' controller
    1.  get all problems from the db using db.problem.findMany() which fetches everything in the table
    2.  return success if there are problems and error if there aren't any
22. 'get-problem-by-id' controller
    1.  verify whether such a problem exist in db using db.problem.findUnique() and return if it does
23. 'update-problem' controller
    1.  copy-paste from 'create-problem' controller and 'get-problem-by-id' controller
    2.  just use db.problem.update({where: {id:problem_id},data: {updated data}})
24. 'delete-problem' controller
    1.  similar to 'get-problem-by-id' controller but use db.problem.delete({where:{id:proble,_id}})
25. DB models   
    1.  model for submission
    2.  model for testcaseresult
    3.  model for problemssolvedbyuser
26. Execution Routes
    1.  file -> controllers -> execution.controller.js
    2.  create a placeholder controller to be filled in later and export it
    3.  file -> routes -> execution.routes.js
    4.  one route for '/' path which should run 'executeCode controller after checking the user (need not be admin) 
    5.  update 'index.js' file to add 'app.use()' section for 'api/v1/execute-code' to executionRouters
27. 'executeCode' controller
    1.  destructure request body and get the required data
    2.  get the userId from request object
    3.  validate the stdin property to check on the testcases and return error on invalid or missing test cases
    4.  prepare each test case for judge0 batch submission by running the .map() function on stdin
    5.  send the prepared batch of submissions to judge0 and get the response
    6.  extract the tokens from the response in an array
    7.  poll judge0 for results for all the submitted test cases until finished
    8.  analyze test case results and check whether all the test cases have passed
    9.  store submission summary into submission table in our db
    10. mark the problem as solved for the user, if all test cases have passed
    11. save individual test case results into testcaseresult table in our db
    12. query the submission table get the submission result with the test case status 
    13. this also verifies whether the data got correctly stored in our db
    14. return the query result with the user along with other standard output and catch any errors in the catch section
28. 'submission' route and controller
    1.  file -> src/routes/submissions.routes.js
        1.  create three routes and export the router - 
            1.  get-all-submissions
            2.  get-submission/:problem-id
            3.  get-submission-count/:problem-id
        2.  add the placeholder controller
    2.  file -> src/containers/submissions.controller.js
        1.  getAllSubmissions controller
            1.  get the userId from request
            2.  search submissions table in db with the user id
            3.  return results to user
        2.  getSubmissionsByProblem controller
            1.  get the user Id from req.user.id and problem Id from request parameter
            2.  search submissions table in db with the user id and problem id
            3.  return the results to user
        3.  getSubmissionCountByProblem controller
            1.  get the problem id from request params
            2.  search submissions table in db with the problem id
            3.  return the results to user
    3.  update index.js
        1.  import the submissionRoutes
        2.  route all the traffic from 'api/v1/submissions/' to use submissionRoutes
29. 'playlist' routes and controller